// Code generated by counterfeiter. DO NOT EDIT.
package dalfakes

import (
	"context"
	"heimdall/internal/dal"
	"heimdall/internal/dal/model"
	"net/url"
	"sync"
	"time"
)

type FakeICommitDAL struct {
	AddCommitsStub        func(context.Context, []model.Commit) error
	addCommitsMutex       sync.RWMutex
	addCommitsArgsForCall []struct {
		arg1 context.Context
		arg2 []model.Commit
	}
	addCommitsReturns struct {
		result1 error
	}
	addCommitsReturnsOnCall map[int]struct {
		result1 error
	}
	CommitsByRepoIdStub        func(context.Context, string, url.Values) (model.CommitList, error)
	commitsByRepoIdMutex       sync.RWMutex
	commitsByRepoIdArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 url.Values
	}
	commitsByRepoIdReturns struct {
		result1 model.CommitList
		result2 error
	}
	commitsByRepoIdReturnsOnCall map[int]struct {
		result1 model.CommitList
		result2 error
	}
	DeleteRepoCommitsStub        func(context.Context, string) error
	deleteRepoCommitsMutex       sync.RWMutex
	deleteRepoCommitsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteRepoCommitsReturns struct {
		result1 error
	}
	deleteRepoCommitsReturnsOnCall map[int]struct {
		result1 error
	}
	RepoLastCommitDateStub        func(context.Context, string) (time.Time, error)
	repoLastCommitDateMutex       sync.RWMutex
	repoLastCommitDateArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	repoLastCommitDateReturns struct {
		result1 time.Time
		result2 error
	}
	repoLastCommitDateReturnsOnCall map[int]struct {
		result1 time.Time
		result2 error
	}
	TopContributorsStub        func(context.Context, int, int) (model.TopContributor, error)
	topContributorsMutex       sync.RWMutex
	topContributorsArgsForCall []struct {
		arg1 context.Context
		arg2 int
		arg3 int
	}
	topContributorsReturns struct {
		result1 model.TopContributor
		result2 error
	}
	topContributorsReturnsOnCall map[int]struct {
		result1 model.TopContributor
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeICommitDAL) AddCommits(arg1 context.Context, arg2 []model.Commit) error {
	var arg2Copy []model.Commit
	if arg2 != nil {
		arg2Copy = make([]model.Commit, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.addCommitsMutex.Lock()
	ret, specificReturn := fake.addCommitsReturnsOnCall[len(fake.addCommitsArgsForCall)]
	fake.addCommitsArgsForCall = append(fake.addCommitsArgsForCall, struct {
		arg1 context.Context
		arg2 []model.Commit
	}{arg1, arg2Copy})
	stub := fake.AddCommitsStub
	fakeReturns := fake.addCommitsReturns
	fake.recordInvocation("AddCommits", []interface{}{arg1, arg2Copy})
	fake.addCommitsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeICommitDAL) AddCommitsCallCount() int {
	fake.addCommitsMutex.RLock()
	defer fake.addCommitsMutex.RUnlock()
	return len(fake.addCommitsArgsForCall)
}

func (fake *FakeICommitDAL) AddCommitsCalls(stub func(context.Context, []model.Commit) error) {
	fake.addCommitsMutex.Lock()
	defer fake.addCommitsMutex.Unlock()
	fake.AddCommitsStub = stub
}

func (fake *FakeICommitDAL) AddCommitsArgsForCall(i int) (context.Context, []model.Commit) {
	fake.addCommitsMutex.RLock()
	defer fake.addCommitsMutex.RUnlock()
	argsForCall := fake.addCommitsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeICommitDAL) AddCommitsReturns(result1 error) {
	fake.addCommitsMutex.Lock()
	defer fake.addCommitsMutex.Unlock()
	fake.AddCommitsStub = nil
	fake.addCommitsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeICommitDAL) AddCommitsReturnsOnCall(i int, result1 error) {
	fake.addCommitsMutex.Lock()
	defer fake.addCommitsMutex.Unlock()
	fake.AddCommitsStub = nil
	if fake.addCommitsReturnsOnCall == nil {
		fake.addCommitsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addCommitsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeICommitDAL) CommitsByRepoId(arg1 context.Context, arg2 string, arg3 url.Values) (model.CommitList, error) {
	fake.commitsByRepoIdMutex.Lock()
	ret, specificReturn := fake.commitsByRepoIdReturnsOnCall[len(fake.commitsByRepoIdArgsForCall)]
	fake.commitsByRepoIdArgsForCall = append(fake.commitsByRepoIdArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 url.Values
	}{arg1, arg2, arg3})
	stub := fake.CommitsByRepoIdStub
	fakeReturns := fake.commitsByRepoIdReturns
	fake.recordInvocation("CommitsByRepoId", []interface{}{arg1, arg2, arg3})
	fake.commitsByRepoIdMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeICommitDAL) CommitsByRepoIdCallCount() int {
	fake.commitsByRepoIdMutex.RLock()
	defer fake.commitsByRepoIdMutex.RUnlock()
	return len(fake.commitsByRepoIdArgsForCall)
}

func (fake *FakeICommitDAL) CommitsByRepoIdCalls(stub func(context.Context, string, url.Values) (model.CommitList, error)) {
	fake.commitsByRepoIdMutex.Lock()
	defer fake.commitsByRepoIdMutex.Unlock()
	fake.CommitsByRepoIdStub = stub
}

func (fake *FakeICommitDAL) CommitsByRepoIdArgsForCall(i int) (context.Context, string, url.Values) {
	fake.commitsByRepoIdMutex.RLock()
	defer fake.commitsByRepoIdMutex.RUnlock()
	argsForCall := fake.commitsByRepoIdArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeICommitDAL) CommitsByRepoIdReturns(result1 model.CommitList, result2 error) {
	fake.commitsByRepoIdMutex.Lock()
	defer fake.commitsByRepoIdMutex.Unlock()
	fake.CommitsByRepoIdStub = nil
	fake.commitsByRepoIdReturns = struct {
		result1 model.CommitList
		result2 error
	}{result1, result2}
}

func (fake *FakeICommitDAL) CommitsByRepoIdReturnsOnCall(i int, result1 model.CommitList, result2 error) {
	fake.commitsByRepoIdMutex.Lock()
	defer fake.commitsByRepoIdMutex.Unlock()
	fake.CommitsByRepoIdStub = nil
	if fake.commitsByRepoIdReturnsOnCall == nil {
		fake.commitsByRepoIdReturnsOnCall = make(map[int]struct {
			result1 model.CommitList
			result2 error
		})
	}
	fake.commitsByRepoIdReturnsOnCall[i] = struct {
		result1 model.CommitList
		result2 error
	}{result1, result2}
}

func (fake *FakeICommitDAL) DeleteRepoCommits(arg1 context.Context, arg2 string) error {
	fake.deleteRepoCommitsMutex.Lock()
	ret, specificReturn := fake.deleteRepoCommitsReturnsOnCall[len(fake.deleteRepoCommitsArgsForCall)]
	fake.deleteRepoCommitsArgsForCall = append(fake.deleteRepoCommitsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteRepoCommitsStub
	fakeReturns := fake.deleteRepoCommitsReturns
	fake.recordInvocation("DeleteRepoCommits", []interface{}{arg1, arg2})
	fake.deleteRepoCommitsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeICommitDAL) DeleteRepoCommitsCallCount() int {
	fake.deleteRepoCommitsMutex.RLock()
	defer fake.deleteRepoCommitsMutex.RUnlock()
	return len(fake.deleteRepoCommitsArgsForCall)
}

func (fake *FakeICommitDAL) DeleteRepoCommitsCalls(stub func(context.Context, string) error) {
	fake.deleteRepoCommitsMutex.Lock()
	defer fake.deleteRepoCommitsMutex.Unlock()
	fake.DeleteRepoCommitsStub = stub
}

func (fake *FakeICommitDAL) DeleteRepoCommitsArgsForCall(i int) (context.Context, string) {
	fake.deleteRepoCommitsMutex.RLock()
	defer fake.deleteRepoCommitsMutex.RUnlock()
	argsForCall := fake.deleteRepoCommitsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeICommitDAL) DeleteRepoCommitsReturns(result1 error) {
	fake.deleteRepoCommitsMutex.Lock()
	defer fake.deleteRepoCommitsMutex.Unlock()
	fake.DeleteRepoCommitsStub = nil
	fake.deleteRepoCommitsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeICommitDAL) DeleteRepoCommitsReturnsOnCall(i int, result1 error) {
	fake.deleteRepoCommitsMutex.Lock()
	defer fake.deleteRepoCommitsMutex.Unlock()
	fake.DeleteRepoCommitsStub = nil
	if fake.deleteRepoCommitsReturnsOnCall == nil {
		fake.deleteRepoCommitsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteRepoCommitsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeICommitDAL) RepoLastCommitDate(arg1 context.Context, arg2 string) (time.Time, error) {
	fake.repoLastCommitDateMutex.Lock()
	ret, specificReturn := fake.repoLastCommitDateReturnsOnCall[len(fake.repoLastCommitDateArgsForCall)]
	fake.repoLastCommitDateArgsForCall = append(fake.repoLastCommitDateArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.RepoLastCommitDateStub
	fakeReturns := fake.repoLastCommitDateReturns
	fake.recordInvocation("RepoLastCommitDate", []interface{}{arg1, arg2})
	fake.repoLastCommitDateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeICommitDAL) RepoLastCommitDateCallCount() int {
	fake.repoLastCommitDateMutex.RLock()
	defer fake.repoLastCommitDateMutex.RUnlock()
	return len(fake.repoLastCommitDateArgsForCall)
}

func (fake *FakeICommitDAL) RepoLastCommitDateCalls(stub func(context.Context, string) (time.Time, error)) {
	fake.repoLastCommitDateMutex.Lock()
	defer fake.repoLastCommitDateMutex.Unlock()
	fake.RepoLastCommitDateStub = stub
}

func (fake *FakeICommitDAL) RepoLastCommitDateArgsForCall(i int) (context.Context, string) {
	fake.repoLastCommitDateMutex.RLock()
	defer fake.repoLastCommitDateMutex.RUnlock()
	argsForCall := fake.repoLastCommitDateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeICommitDAL) RepoLastCommitDateReturns(result1 time.Time, result2 error) {
	fake.repoLastCommitDateMutex.Lock()
	defer fake.repoLastCommitDateMutex.Unlock()
	fake.RepoLastCommitDateStub = nil
	fake.repoLastCommitDateReturns = struct {
		result1 time.Time
		result2 error
	}{result1, result2}
}

func (fake *FakeICommitDAL) RepoLastCommitDateReturnsOnCall(i int, result1 time.Time, result2 error) {
	fake.repoLastCommitDateMutex.Lock()
	defer fake.repoLastCommitDateMutex.Unlock()
	fake.RepoLastCommitDateStub = nil
	if fake.repoLastCommitDateReturnsOnCall == nil {
		fake.repoLastCommitDateReturnsOnCall = make(map[int]struct {
			result1 time.Time
			result2 error
		})
	}
	fake.repoLastCommitDateReturnsOnCall[i] = struct {
		result1 time.Time
		result2 error
	}{result1, result2}
}

func (fake *FakeICommitDAL) TopContributors(arg1 context.Context, arg2 int, arg3 int) (model.TopContributor, error) {
	fake.topContributorsMutex.Lock()
	ret, specificReturn := fake.topContributorsReturnsOnCall[len(fake.topContributorsArgsForCall)]
	fake.topContributorsArgsForCall = append(fake.topContributorsArgsForCall, struct {
		arg1 context.Context
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.TopContributorsStub
	fakeReturns := fake.topContributorsReturns
	fake.recordInvocation("TopContributors", []interface{}{arg1, arg2, arg3})
	fake.topContributorsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeICommitDAL) TopContributorsCallCount() int {
	fake.topContributorsMutex.RLock()
	defer fake.topContributorsMutex.RUnlock()
	return len(fake.topContributorsArgsForCall)
}

func (fake *FakeICommitDAL) TopContributorsCalls(stub func(context.Context, int, int) (model.TopContributor, error)) {
	fake.topContributorsMutex.Lock()
	defer fake.topContributorsMutex.Unlock()
	fake.TopContributorsStub = stub
}

func (fake *FakeICommitDAL) TopContributorsArgsForCall(i int) (context.Context, int, int) {
	fake.topContributorsMutex.RLock()
	defer fake.topContributorsMutex.RUnlock()
	argsForCall := fake.topContributorsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeICommitDAL) TopContributorsReturns(result1 model.TopContributor, result2 error) {
	fake.topContributorsMutex.Lock()
	defer fake.topContributorsMutex.Unlock()
	fake.TopContributorsStub = nil
	fake.topContributorsReturns = struct {
		result1 model.TopContributor
		result2 error
	}{result1, result2}
}

func (fake *FakeICommitDAL) TopContributorsReturnsOnCall(i int, result1 model.TopContributor, result2 error) {
	fake.topContributorsMutex.Lock()
	defer fake.topContributorsMutex.Unlock()
	fake.TopContributorsStub = nil
	if fake.topContributorsReturnsOnCall == nil {
		fake.topContributorsReturnsOnCall = make(map[int]struct {
			result1 model.TopContributor
			result2 error
		})
	}
	fake.topContributorsReturnsOnCall[i] = struct {
		result1 model.TopContributor
		result2 error
	}{result1, result2}
}

func (fake *FakeICommitDAL) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addCommitsMutex.RLock()
	defer fake.addCommitsMutex.RUnlock()
	fake.commitsByRepoIdMutex.RLock()
	defer fake.commitsByRepoIdMutex.RUnlock()
	fake.deleteRepoCommitsMutex.RLock()
	defer fake.deleteRepoCommitsMutex.RUnlock()
	fake.repoLastCommitDateMutex.RLock()
	defer fake.repoLastCommitDateMutex.RUnlock()
	fake.topContributorsMutex.RLock()
	defer fake.topContributorsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeICommitDAL) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ dal.ICommitDAL = new(FakeICommitDAL)
